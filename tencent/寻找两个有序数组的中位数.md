## 寻找两个有序数组的中位数

```
题目：寻找两个有序数组的中位数
题库题号：4
题目难度：困难
要求：给定两个大小为nums1和nums2
找出有序数组的中位数
执行用时：136ms
```

- 我的解法：战胜了67.76%的，和上一个比较好很多。
- 影响速度的关键就是排序问题：相当于把两个有序的数组进行整合排序。

```python
#基本思路
def test(nums1,nums2):
    c = 0
    for x in range(len(nums2)):
        for y in range(c,len(nums1)):
            if nums2[x] <= nums1[y]:
                nums1.insert(y,nums2[x])
                print(nums1)
                c = y
                break
        if nums2[x] > nums1[y]:
            nums1.insert(y+1,nums2[x])

        print(nums1)
    return zhong(nums1)

def zhong(nums): 
    length = len(nums)
    if length % 2 == 0 :
        zhong = (nums[int(length/2)-1]+nums[int(length/2)])/2
        zhong_pos = [length/2-1,length/2]
    else:
        zhong = nums[length//2]
        zhong_pos = [length//2]
    return zhong



if __name__ == '__main__':
    l = [1,2]
    m = [3,4]
    if len(l) >= len(m):
        a = test(l,m)
    else:
        a = test(m,l)
    print(a)
```

```python
#leetcode可提交
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def test(nums1,nums2):
            c = 0
            for x in range(len(nums2)):
                for y in range(c,len(nums1)):
                    if nums2[x] <= nums1[y]:
                        nums1.insert(y,nums2[x])
                        c = y  #用了c来减少循环次数
                        break
                if nums2[x] > nums1[y]:
                    nums1.insert(y+1,nums2[x])
                    c = y
                    
            return zhong(nums1)

        def zhong(nums): 
            length = len(nums)
            if length % 2 == 0 :
                zhong = (nums[int(length/2)-1]+nums[int(length/2)])/2
            else:
                zhong = nums[length//2]
            return zhong
        
        if len(nums1) >= len(nums2):
            return test(nums1,nums2)
        else:
            return test(nums2,nums1)
```

- 看到的100ms的..直接调用了extend函数和sort函数。

  ```python
  class Solution:
      def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
          nums1.extend(nums2)
          nums1.sort()
          if len(nums1) % 2 == 0:
              return sum(nums1[len(nums1)//2 - 1:len(nums1)//2 + 1:]) / 2
          else:
              return (nums[len(nums)//2] + nums[len(nums)//2-1])/2
  
  ```